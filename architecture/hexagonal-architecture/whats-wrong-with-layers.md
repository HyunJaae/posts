## 01. 계층형(Layered) 아키텍처의 문제는 무엇일까? (What’s Wrong with Layers?)
아래는 우리가 흔히 알고 있는 3계층 아키텍처를 표현한 그림입니다.

![layered architecture](/images/architecture/hexagonal-architecture/layered-architecture.png)

맨 위의 **웹 계층**에서는 요청을 받아 **도메인** 혹은 비즈니스 계층에 있는 서비스로 요청을 보냅니다. 서비스에서는 필요한 비즈니스 로직을 수행하고, 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 **영속성** 계층의 컴포넌트를 호출합니다.

사실 계층형 아키텍처는 견고한 아키텍처 패턴입니다. 계층을 잘 이해하고 구성한다면 웹 계층이나 영속성 계층에 독립적으로 도메인 로직을 작성할 수 있습니다. 또한 원한다면 도메인 로직에 영향을 주지 않고 웹 계층과 영속성 계층에 사용된 기술을 변경할 수 있습니다.

### 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.
**웹 계층은 도메인 계층에 의존하고, 도메인 계층은 영속성 계층에 의존하기 대문에 자연스레 데이터베이스에 의존하게 된다.**
모든 것이 영속성 계층을 토대로 만들어진다.

우리가 만든 대부분의 어플리케이션에서 상태(state)가 중요한 요소이긴 하지만 행동(behavior)이 상태를 바꾸는 주체이기 때문에 행동이 비즈니스를 이끌어갑니다. 따라서 우리는 행동을 중심으로 애플리케이션을 모델링합니다.

하지만 계층형 아키텍처에서는 상태(state), 즉 영속성 계층을 먼저 모델링하게 되는데 가장 큰 원인은 ORM(Object-Relational Mapping, 객체 관계 매핑)을 사용하기 때문입니다.

![domain persistence coupling](/images/architecture/hexagonal-architecture/domain-persistence-coupling.png)

위 그림에서와 같이 ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 두게 되면서 영속성 계층과 도메인 계층 사이에 강한 결합이 발생합니다. 이로 인해 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되는데 도메인 로직뿐 아니라 즉시로딩(eager loading)/지연로딩(lazy loading), 트랜잭션 등 영속성 계층과 관련된 작업들을 하게 됩니다.

영속성 코드가 도메인 코드에 녹아들어가면서 둘 중 하나만 변경하는 것이 어려워지고 이는 유연하고 선택의 폭을 넓혀준다는 계층형 아키텍처의 목표와 완전히 상반되는 결과를 가져옵니다.

### 지름길을 택하기 쉬워진다.
전통적인 계층형 아키텍처에서 전체적으로 적용되는 유일한 규칙은, 특정 계층에서는 같은 계층에 있는 컴포넌트 또는 하위 계층에만 접근이 가능하다는 것입니다.

따라서 만약 상위 계층에 위치한 컴포넌트에 접근해야 한다면 간단하게 컴포넌트를 하위 계층으로 내려버리는 지름길을 선택하게 됩니다. 이런 선택이 계속해서 쌓인다면 아래의 그림과 같이 영속성 계층이 비대해집니다.

![increment persistence layer](/images/architecture/hexagonal-architecture/increment-persistence-layer.png)

### 테스트하기 어려워진다.
계층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 계층을 건너뛰는 것입니다. 엔티티의 필드를 단 하나만 조작하면 되는 경우에 웹 계층에서 바로 영속성 계층에 접근하면 도메인 계층을 건드릴 필요가 없다고 생각하는 경우입니다. 이런 일이 쌓이다보면 두 가지의 문제점이 발생하는데 첫 번째로 도메인 로직이 코드 전반에 걸쳐 흩어진다는 점입니다.

두 번째 문제는 웹 계층 테스트 시 도메인 계층뿐 아니라 영속성 계층도 모킹(mocking)해야 한다는 점입니다. 이렇게 되면 단위 테스트의 복잡도가 올라갑니다. 그리고 테스트 설정이 복잡해진다는 것은 테스트틀 전혀 작성하지 않는 방향으로 가는 첫걸음입니다.

### 유스케이스(UseCase)를 숨긴다.
실제로 개발할 때는 새로운 코드를 짜는 것보다 기존 코드를 바꾸는데 더 많은 시간을 할애합니다. 기능을 추가하거나 변경할 적절한 위치를 찾는 일이 빈번하기 때문에 아키텍처는 코드를 빠르게 탐색하는데 도움이 돼야 합니다.

하지만 계층형 아키텍처는 앞서 살펴본 바와 같이 도메인 로직이 여러 계층에 흩어지기 쉽기 때문에 새로운 기능을 추가하거나 변경할 적당한 위치를 찾는게 어려워집니다.

또한 계층형 아키텍처는 도메인 서비스의 **너비**에 관한 규칙을 강제하지 않습니다. 그렇기 때문에 아래 그림과 같은 여러 개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어지기도 합니다. 한마디로 하나의 도메인 서비스가 너무 많은 책임을 갖게 되면서 테스트하거나 변경하기에 어려운 구조를 갖게 됩니다.

![fat-service](/images/architecture/hexagonal-architecture/fat-service.png)

### 동시 작업이 어려워진다.

계층형 아키텍처에서는 모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야 하고, 그 다음에 도메인 계층을, 그리고 마지막으로 웹 계층을 만들어야 합니다. 그렇기 때문에 특정 기능을 추가한다면 동시에 한 명의 개발자만 작업할 수 있습니다. 따라서 계층별로 나누어 작업할 수 없습니다.

또한 넓은 서비스가 있다면 같은 서비스를 동시에 편집하는 상황이 발생하고, 이는 병합 충돌(merge conflict)와 잠재적으로 이전 코드로 되돌려야 하는 문제를 야기하기 합니다.

> 실제로 회사에서 개발을 할 때 계층형 아키텍처로 프로젝트를 구성하고 진행해 왔는데 위에서 말한 모든 문제를 겪었다.
>
> 테이블 설계부터 진행하고 거기에 맞춰 영속성 객체를 만들고, 하나의 기능은 한 명의 개발자가 담당해서 개발해야 했다. 비즈니스 로직은 점점 커지고 요구사항이 추가되거나 변경될 때마다 연관된 모든 코드를 살펴보느라 많은 시간을 허비했다.
>
> 코드를 이해하는 것도 어려웠고 테스트 코드는 시작할 엄두도 나지 않았다. 인터페이스를 써도 내가 만든 애플리케이션은 유연하지 못하고 너무나 뻣뻣한 느낌이었다. 물론 계층형 아키텍처만의 문제는 아니었겠지만 그동안 쌓여있던 답답함이 위 내용을 읽으며 많은 부분에서 해소될 수 있었다.